<script setup lang="ts">
import AppSection from '@/components/section/app-section.vue'
import MusicPlayer from '@/structures/list/examples/music-player/music-player.vue'
import PaintCanvas from '@/structures/list/examples/paint/paint-canvas.vue'
</script>

<template>
  <app-section
    title="Связный список"
    source="https://github.com/RuSaG0/js-data-structures/tree/master/src/structures/list"
  >
    <template #description>
      <p>
        Связный список — это структура данных, состоящая из узлов, где каждый узел содержит данные и
        ссылку на следующий узел в последовательности. В контексте frontend-разработки связные
        списки могут быть использованы для:
      </p>
      <ul>
        <li>
          Реализации музыкального плеера, где они позволяют легко перемещаться между треками,
          добавлять и удалять их из плейлиста.
        </li>
        <li>
          Редакторов, поддерживающих операции отмены и возврата действий (undo-redo), таких как
          текстовый редактор Word или графический редактор Figma, где связные списки помогают
          эффективно управлять историей изменений.
        </li>
      </ul>
    </template>

    <template #example1>
      <p>Реализация музыкального плеера</p>
      <music-player />
    </template>

    <template #example2>
      <p>Реализация графического редактора с функциональностью undo / redo</p>
      <paint-canvas />
    </template>

    <template #pros>
      Преимущество связного списка заключается в том, что удаление элемента выполняется за
      константное время O(1). В массиве для удаления элемента необходимо не только удалить сам
      элемент, но и сдвинуть все последующие элементы. В связном списке же достаточно изменить
      ссылки prev и next у соответствующей ноды.
    </template>

    <template #cons>
      <p>
        Одним из недостатков использования двусвязного кольцевого списка является сложность
        автоматической очистки сборщиком мусора. Алгоритм сборщика мусора может не понять, как
        удалить такой список, поскольку все элементы ссылаются друг на друга, создавая кольцевую
        зависимость.
      </p>
      <strong>Решение:</strong><br />
      Для решения этой проблемы можно использовать слабые ссылки (<a
        target="_blank"
        href="https://learn.javascript.ru/weakref-finalizationregistry"
        >Weak References</a
      >). Слабые ссылки позволяют сборщику мусора удалять объекты, на которые они указывают, даже
      если на эти объекты существуют другие слабые ссылки. Это помогает избежать утечек памяти,
      связанных с кольцевыми зависимостями.
    </template>
  </app-section>
</template>
