import{d as r,r as v,o as h,l as w,c as l,a as n,b as s,F as y,f as b,t as a,e as d,i as m,_ as x,w as p,k as E,j as g,u as C}from"./index-CO4fXZPx.js";import{_ as L}from"./_plugin-vue_export-helper-DlAUqK2U.js";class M{items=[];push(t){this.items.push(t)}pop(){return this.items.pop()}getItems(){return[...this.items]}size(){return this.items.length}get(t){if(t>=0&&t<this.items.length)return this.items[t]}isEmpty(){return this.items.length===0}}const B={class:"modal-flow"},F={class:"modal__content"},I={class:"modal__body"},T={class:"modal__title"},D={class:"modal__text"},N={class:"modal__buttons"},S=r({__name:"modal-flow-case",setup(i){const t=v(new M),e=()=>{t.value.push({id:1,title:"Удаление аккаунта",content:"Вы хотите удалить аккаунт?",buttonText:"Да, хочу удалить"})},f=()=>{t.value.push({id:2,title:"Подтверждение удаления",content:"Вы уверены, что хотите удалить аккаунт? Данные о вас будут потеряны навсегда.",buttonText:"Да, я уверен, удалить"})},c=()=>{t.value.isEmpty()||t.value.pop()},k=()=>{for(;!t.value.isEmpty();)t.value.pop()},u=_=>{_.key==="Escape"&&c()};return h(()=>{window.addEventListener("keydown",u)}),w(()=>{window.removeEventListener("keydown",u)}),(_,A)=>(n(),l("div",B,[s("button",{class:"modal-flow__button-delete",onClick:e}," Удалить аккаунт "),(n(!0),l(y,null,b(t.value.getItems(),o=>(n(),l("div",{key:o.id,class:"modal"},[s("div",F,[s("div",{class:"modal__close",onClick:c},"×"),s("div",I,[s("h3",T,a(o.title),1),s("p",D,a(o.content),1)]),s("div",N,[o.id===1?(n(),l("button",{key:0,onClick:f},a(o.buttonText),1)):d("",!0),o.id===2?(n(),l("button",{key:1,onClick:k},a(o.buttonText),1)):d("",!0)])])]))),128))]))}}),V=L(S,[["__scopeId","data-v-39f25af3"]]),$=r({__name:"view-stack",setup(i){return(t,e)=>(n(),m(x,{title:"Стек"},{description:p(()=>e[0]||(e[0]=[g(" Стек — это структура данных, работающая по принципу LIFO (Last In, First Out), что означает, что последний добавленный элемент будет первым извлечён. В frontend-разработке стек полезен для управления историей навигации или для валидации данных. ")])),example1:p(()=>[e[1]||(e[1]=s("p",null,"Реализация потока модальных окон",-1)),e[2]||(e[2]=s("p",null,"Представим ситуацию, когда у нас есть два модальных окна:",-1)),e[3]||(e[3]=s("ul",null,[s("li",null,'Модальное окно удаления аккаунта. Открывается по кнопке "Удалить аккаунт".'),s("li",null,' Модальное окно подтверждения удаления аккаунта. Открывается после нажатия на кнопку "Да, хочу удалить" в первом модальном окне. ')],-1)),e[4]||(e[4]=s("p",null," При этом у нас возникает следующая дилемма: мы хотим написать код, чтобы при нажатии на клавишу Esc модальное окно закрывалось, но при обычной реализации, если на обеих модальных окнах стоит обработчик закрытия по нажатию Esc, они закроются одновременно. Решение заключается в том, чтобы складывать модальные окна в Stack, тогда при нажатии на Esc удалится последний элемент из стека, в котором содержатся обе модалки. ",-1)),E(V)]),_:1}))}}),z=r({__name:"page-stack",setup(i){return(t,e)=>(n(),m(C($)))}});export{z as default};
